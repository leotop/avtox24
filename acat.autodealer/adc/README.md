Каталог от компании АвтоДилер
==============================

#### Принимаемые параметры:

```
getTypeList  - вернет список типов (легковые, грузовые, ..) автомобилей, исходя из доступных для пользователя и включенных панели управления. 
 
getMarkList  - вернет список марок по переданному в функцию ID типа автомобиля.  

getModelList - по ID типа и ID марки вернет список моделей, учитывая пользовательские настройки.  

getTreeList  - по ID модели вернет дерево деталей.  
При передачи второго произвольного значения вернет мильти-архив с вложенными зависимостями.  
Если второй параметр не передать, то возвращает просто выборку в виде одноуровнего массива. 
Для нашего примера - это наилучший выбор (пример в adc/tree.php) 
                
getDetails   - по ID модели и ID детали (treeID) вернет саму деталь:  
               1. Иллюстрацию с метками расположениями
               2. Список номенклатуры, связанные с метками на иллюстрации

searchModels - вернет все варианты имен моделей по введенным данным

searchNumber - номер детали (вводится в поле) => дерево как от getTreeList() по возможным вариантам

typeID  - идентификатор типа
markID  - идентификатор марки
modelID - идентификатор модели

multiArray - необязательный параметр. Используется в четвертом запросе.
```

---



#### ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ


##### №1. Получить список всех типов автомобилей, относительно Ваших настроек:

```
http://auto2d.com/api/in.php?f=getTypeList&u=%s&p=%s
```

###### В скрипте пользователя (types.php):
```
include "_lib.php";         - подключаем общую библиотеку
include "adc/api.php";      - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работы

$aTypeList = $oA2D->getTypeList(); - запрашиваем список типов автомобилей

$aErrors = A2D::property($aTypeList,'errors');      - отлавливаем ошибку(и) из ответа
if(count($aErrors)>0){ $oA2D->error($aErrors,404); } - если есть, то печатаем
                                                    - обработка ошибок идентична для всех запросов
                                                    - далее момент обработки ошибок нет смысла дублировать
```

###### Под капотом:
```
---так функция выглядит в adc/api.php

public function getTypeList(){
    $body = "f=".__FUNCTION__.$this->_auth;
    $answer = $this->getAnswer($body);
    $r = json_decode($answer);
    return $r;
}

$body = "f=".__FUNCTION__.$this->_auth; - формируем строку запроса
    
    __FUNCTION__ принимает значение getTypeList. По данному параметру на сервере решается какая функция будет отрабатывать
    в $this->_auth находятся ваши логин/пароль от сервиса auto2d.com

$answer = $this->getAnswer($body); - отправляем запрос и получаем ответ в виде строки
   
   функция $this->getAnswer($body) использует cURL для отправки запроса

$r = json_decode($answer); - декодирует json строку
    на выходе получаем массив объектов
    каждый объект имеет следующие свойства:
        type_id   - идентификатор типа
        type_name - текстовое наименование типа
        type_url  - адрес картинки для типа, размещенной на сервере. Можно использовать что-то свое
```

###### Обработка данных:
```
... кусок из types.php ...

<?php foreach($aTypeList as $aType){?> - пробегаемся по массиву
    <tr>
        <td align="center" valign="middle" width="100">
            ... изображение марки ...
            <a href="marks.php?typeID=<?=$aType->type_id?>"> - ссылка при клике
                <img src="<?=$aType->type_url?>" width="80" height="50" alt="<?=$aType->type_name?>" border="0"> - само изображение
            </a>
            ... / изображение марки ...
        </td>
        <td align="left" valign="middle" class="rbrd">
            ... название марки ...
            <a href="marks.php?typeID=<?=$aType->type_id?>" style="font-size: 14pt"> - ссылка при клике
                <?=$aType->type_name?> - названия типа
            </a>
            ... / название марки ...
        </td>
    </tr>
<?php }?>

... / кусок из types.php ...
```

---


##### №2. Получить список марок
```
http://auto2d.com/api/in.php?f=getMarkList&u=%s&p=%s&typeID=%s
```

###### В скрипте пользователя (marks.php):
```
include "_lib.php";         - подключаем общую библиотеку
include "adc/api.php";      - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - Создаем объект для работы

$sTypeID   = $oA2D->rcv('typeID');         - Получаем идентификатор типа
$aMarkList = $oA2D->getMarkList($sTypeID); - Запрашиваем список моделей по выбранному типу
                                            Если не передать параметр, то вернет все модели относительно пользовательских настроек.
                                            Возвращается объект с данными.
$aMarkList = A2D::property($oMarkList,'marks');    - Список всех марок в виде объекта
$sTypeName = A2D::property($oMarkList,'typeName'); - Наименование типа автомобиля. Используется в "хлебных крошках".
                                                     Если не передали ID типа, возвращается FALSE
```

###### Под капотом:
```
---так функция выглядит в adc/api.php

public function getMarkList($type){
    $body = "f=".__FUNCTION__.$this->_auth."&typeID=$type";
    $answer = $this->getAnswer($body);
    $r = json_decode($answer);
    return $r;
}

$body = "f=".__FUNCTION__.$this->_auth."&typeID=$type"; - формируем строку запроса

    __FUNCTION__ принимает значение getMarkList. По данному параметру на сервере решается какая функция будет отрабатывать
    в $this->_auth находятся ваши логин/пароль от сервиса auto2d.com
    переменная typeID принимает передаваемое значение идентификатора типа $type

$answer = $this->getAnswer($body); - отправляем запрос и получаем ответ в виде строки
    
    функция $this->getAnswer($body) использует cURL для отправки запроса

$r = json_decode($answer); - декодирует json строку
    на выходе получаем объект с двумя свойствами:
        marks - массив марок в виде объектов со следующими свойствами:
            type_id        - идентификатор типа
            mark_id        - идентификатор марки
            mark_img_url   - адрес картинки для марки, размещенной на сервере. Можно использовать что-то свое
            mark_name]     - краткое название марки
            mark_name_full - полное название марки
            mark_url       - официальный сайт производителя
        typeName - Наименование типа автомобиля. Используется в "хлебных крошках".
```

###### Обработка данных:
```
Пример обработки полученных данных можно посмотреть в marks.php
```

---


##### №3. Получить список моделей
```
http://auto2d.com/api/in.php?f=getModelListt&u=%s&p=%s&typeID=%s&markID=%s
```

###### В скрипте пользователя (adc/models.php):
```
include "_lib.php";               - подключаем общую библиотеку
include "adc/api.php";            - подключаем API для текущего каталога
$oA2D = A2DAPI::instance();        - создаем объект для работы
$sTypeID = $oA2D->rcv('typeID');   - получаем идентификатор типа
$sMarkID = $oA2D->rcv('markID');   - получаем идентификатор марки

$oModelList = $oA2D->getModelList($sTypeID,$sMarkID); - возвращается объект с данными
$aModelList = A2D::property($oModelList,'models');   - Массив всех моделей в виде объектов
                             Каждый объект обладает следующими свойствами:
                                 mark_id            - Идентификатор марки
                                 model_id           - Идентификатор модели
                                 model_url          - Путь до изображения модели
                                 model_name         - Имя модели
                                 model_modification - Модификации
                                 model_actual       - Актуальность каталога
                                 model_years        - Период выпуска модели
                                 model_archival     - Признак архивного каталога (информация могла устареть): 1 - архивный, 0 - не архивный
$sTypeName  = A2D::property($oModelList,'typeName'); - Наименование типа автомобиля. Используется в "хлебных крошках".
$sMarkName  = A2D::property($oModelList,'markName'); - Наименование марки автомобиля. Используется в "хлебных крошках" и заголовке.

$bMultiArray = 1; - параметр может принимать любое значение - это TRUE, отсутсвие значения - это FALSE
                  - сервер может возвращать два вида массивов для моделей
                    1. Линейный - очень хорошо подходит для php. Удобно строить DOM.
                    2. Мульти-архив - если нужно распарсить еще. В таком виде явно видно потомков и предков.
```

###### Под капотом:
```
По первым двум примерам можно легко увидеть, что эта часть незначительно отличается.
Саму функцию можно посмотерть в _lib.php
Посмотерть возвращаемые данные можно просто раскомментировав строку:
//$oA2D->e($oModelList);
---далее эта часть будет опускаться
```

###### Обработка данных:
```
Пример обработки полученных данных можно посмотреть в adc/models.php
---далее эта часть будет опускаться
```

---

##### №4. Получить список всех деталей для текущей марки
```
http://auto2d.com/api/in.php?f=getTreeList&u=%s&p=%s&multiArray=1&modelID=%s
```

###### В скрипте пользователя (tree.php):
```
include "_lib.php";        - подключаем общую библиотеку
include "adc/api.php";     - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работа

$sModelID    = $oA2D->rcv('modelID');              - получаем идентификатор модели
$bMultiArray = (boolean) $oA2D->rcv('multiArray'); - какой тип массива запрашивать с сервера

$oTreelList  = $oA2D->getTreeList($sModelID,$bMultiArray); - Вернет объект данных для текущий модели
$aTreelList  = AD::property($oTreelList ,'details');      - Список деталей ввиде объекта
                                                            Если существуют multiArray, то вернется объект мульти-архива
                                                            В противоположном случае - объект, полученный из линейного массива
$sModelName  = AD::property($oTreelList ,'modelName');    - Имя модели

$sTypeID     = A2D::property($oTreelList,'typeID');      - Идентификатор типа автомобиля. Используется в "хлебных крошках".
$sTypeName   = A2D::property($oTreelList,'typeName');    - Наименование типа автомобиля. Используется в "хлебных крошках".
$sMarkID     = A2D::property($oTreelList,'markID');      - Идентификатор марки автомобиля. Используется в "хлебных крошках".
$sMarkName   = A2D::property($oTreelList,'markName');    - Наименование марки автомобиля. Используется в "хлебных крошках".
$sModelName  = A2D::property($oTreelList,'modelName');   - Наименование модели автомобиля. Используется в "хлебных крошках" и заголовке.
```

---

##### №5. Получить изображение выбранной детали
```
http://auto2d.com/api/in.php?f=getDetails&u=%s&p=%s&modelID=%s&treeID=%s&jumpPic=%s
```

###### В скрипте пользователя (map.php):
```
include "_lib.php";        - подключаем общую библиотеку
include "adc/api.php";     - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работы

$sTreeID  = $oA2D->rcv('treeID');  - получаем идентификатор типа
$sModelID = $oA2D->rcv('modelID'); - получаем идентификатор модели
$sJumpPic = $oA2D->rcv('jumpPic'); - если есть, то это идентификатор части изображения в более подробном виде со своим списком номенклатуры

$vMapImg  = $oA2D->getDetails($sModelID,$sTreeID); - отправляем запрос

$sTypeID    = A2D::property($vMapImg,'typeID');      - Идентификатор типа автомобиля. Используется в "хлебных крошках".
$sTypeName  = A2D::property($vMapImg,'typeName');    - Наименование типа автомобиля. Используется в "хлебных крошках".
$sMarkID    = A2D::property($vMapImg,'markID');      - Идентификатор марки автомобиля. Используется в "хлебных крошках".
$sMarkName  = A2D::property($vMapImg,'markName');    - Наименование марки автомобиля. Используется в "хлебных крошках".
$sModelName = A2D::property($vMapImg,'modelName');   - Наименование модели автомобиля. Используется в "хлебных крошках" и заголовке.
$sTreeName  = A2D::property($vMapImg,'treeName');    - Наименование ветки дерева для детали. Используется в "хлебных крошках" и заголовке.
$sMapName   = A2D::property($vMapImg,'mapName');
$sMapNameTree = ((strlen($sMapName)>43)?substr($sMapName, 0, 40)."...":$sMapName);

$sMapName = A2D::property($vMapImg,'mapName'); - название детали/представления/фрейма (далее Карта)
$mapImg   = A2D::property($vMapImg,'mapImg');  - изображением с метками
$aDetails = A2D::property($vMapImg,'detail');  - список номенклатуры
$aNav     = A2D::property($vMapImg,'nav');     - предыдущая и следующая деталь, относительно дерева
$_prev    = A2D::property($aNav,'prev');       - предыдущая
$_next    = A2D::property($aNav,'next');       - следующая
$imgPath  = $oA2D->getImgPath();                 - путь иллюстрации на сервере
                                                  запрос внутри библиотеки на стороне клиента возвращает путь из имеющихся данных
                                                  картинки можно выкачать и не бегать за ними каждый раз
                                                  или использовать свои, если есть желание изменить интерфейс
```

Можно влиять на поведение js скриптов:

1. При клике по номенклатуре, чтобы подсветить номер детали используется скрипт функция td, что можно посмотреть в скрипте пользователя **adc/map.php**
   Тут все просто - пишем свое решение и используем.
2. При клике по номеру детали на самой картинки используется внутренний скрипт, поведение которого можно переопределить или дополнить!
   Чтобы дополнить функционал, добавтье в конец вашего **adc/map.php** следующий скрипт:

```
<script>
    exLightsTR = function(id){
        alert(id);
    };
</script>
```

Для полной изоляции нужно добавить еще *return false;* :

```
<script>
    exLightsTR = function(id){
        alert(id);
        return false;
    };
</script>
```

Загрузка изображения происходит через **iframe.js**  
В данном скрипте используется **window.onload**  
Это зачастую не дает отработать другим скриптам, рассчитанных на это событие  
Для этих целей была придумана функция **apiReady()**, которыя вызывается внутри фрейма  
Данная функция вызывается, когда все другие функции отработали  
Если у вас есть необходимость, то просто реализуйте со своей стороны данную функцию  
Объявить функцию нужно до загрузки **iframe.js**  

---

##### №6. Получение детальной информации по выбранной детали
```
http://auto2d.com/api/in.php?f=getDetailInfo&u=%s&p=%s&modelID=%s&treeID=%s
```

###### В скрипте пользователя (adc/getDetailInfo.php):
```
include "_lib.php";        - подключаем общую библиотеку
include "adc/api.php";     - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работы

$sTreeID  = $oA2D->rcv('treeID');  - получаем идентификатор типа
$sModelID = $oA2D->rcv('modelID'); - получаем идентификатор модели

$aInfo    = $oA2D->getDetailInfo($sModelID,$sTreeID); - функция запроса

$aErrors = A2D::property($aInfo,'errors');          - ловим ошибки
if(count($aErrors)>0){ $oA2D->error($aErrors,404); } - обрабатываем ошибки, если есть

С сервера возвращается объект. К примеру, с таким содержанием:

[auto]         => Shaanxi Fast Gear RT                     - Модель, к которой принадлежит детать
[detail_name]  => Шестерня 3-ей передачи второго вала      - Наименование детали
[detail_no]    => JS119-1701113                            - Номер детали в каталогах
[modification] => RT-11509C,  RTO-11509F                   - Модификации модели
[actual]       =>                                          - Актуальность каталога
[count]        => stdClass Object                          - объект
    (
        [8] => 1 - для Shaanxi Fast Gear 9JS119            - Сколько раз встречается и в какой модификации
    )
```

---

##### №7. Поиск модели
```
http://auto2d.com/api/in.php?f=searchModels&u=%s&p=%s&model=%s
```
>В переменной model должно находиться примерное имя или номер модели (например: 211_, ВА_), иначе вернется пустой ответ.

###### В скрипте пользователя (adc/search/models.php):
```
include "_lib.php";        - подключаем общую библиотеку
include "adc/api.php";     - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работы

$sModel = $oA2D->rcv('searchModels');        - обрабатываем строку поиска из types.php
$aModelsList = $oA2D->searchModels($sModel); - отправляем запрос

$aErrors = A2D::property($aModelsList,'errors');      - ловим ошибки
if( count($aErrors)>0 ){ $oA2D->error($aErrors,404); } - обрабатываем ошибки, если есть

$multiArray=''; - так как переход идет на дерево деталей, то указываем какой массив получаем
                  если существуют multiArray, то вернется объект мульти-архива. По умолчанию пользовательские скрипты настроены на простой массив
```

###### Пример ответа от сервера:
```
    actual         : "08.2012"                                                         - Актуальность каталога
    archival       : "0"                                                               - Признак архивного каталога (информация могла устареть): 1 - архивный, 0 - не архивный
    mark_id        : "40"                                                              - Идентификатор марки
    mark_name      : "ВАЗ"                                                             - Имя марки
    mark_name_full : "Волжский автомобильный завод (Российская Федерация, г.Тольятти)" - Полное имя марки
    model_id       : "37534"                                                           - Идентификатор модели
    model_name     : "Largus"                                                          - Имя модели
    model_url      : "http://auto2d.com/img/Models/37534.jpg"                          - Изображение модели. Если пусто, то изображение отсутствует
    modification   : "FS015-40 (5-дверный 2-местный фургон)"                           - Модификации модели
    type_id        : "1"                                                               - Идентификатор типа для модели
    years          : ""                                                                - Период выпуска модели
```
>На сервере стоит ограничение на отдаваемый результат, чтобы снизить нагрузку на сервер.  
Да и ответ с более 100 позициями зачастую бессмыслен.  
Поэтому, если в ответе более 100 позиций, то с сервера возвращается первых 100 актуальных.  
Совет: рекомендуем считать кол-во элементов и если `count(el)=>100`, выводить пользователю просьбу `уточнить запрос`


---

##### №8. Поиск детали
```
http://auto2d.com/api/in.php?f=searchNumber&u=%s&p=%s&modelID=%s&search=%s
```
>search  - строка поиска/номер детали  
modelID - идентификатор модели (необязательный параметр)
Если указать modelID, искать будет в рамках текущей модели и на вхождение  
Если не указывать modelID, то поиск пойдет по точному совпадению номера  

###### В скрипте пользователя (adc/search/detail.php):
```
include "_lib.php";        - подключаем общую библиотеку
include "adc/api.php";     - подключаем API для текущего каталога
$oA2D = A2DAPI::instance(); - создаем объект для работы

$detail = $oA2D->rcv('detail');

if( $detail ){

    $aDetails = $oA2D->searchNumber($detail); ///$oA2D->e($aDetails);
    
    $aErrors = A2D::property($aDetails,'errors');
    if( count($aErrors)>0 )$oA2D->error($aErrors,404);
}

```
>Полный пример в adc/search/detail.php

###### С сервера отдает массив объектов со следующими свойствами:
```
[model_id]     => 15407                                             - Идентификатор модели
[model_name]   => 318i                                              - Имя модели
[modification] => Двигатель: M43  Кузов: E46 седан                  - Модификации
[mark_id]      => 3                                                 - Идентификатор марки
[tree_id1]     => 871809                                            - Идентификатор узла
[tree_id2]     => 871813                                            - Идентификатор узла
[tree_id3]     => 871825                                            - Идентификатор узла
[detail_id]    => 10014743                                          - Идентификатор детали в базе
[mark_name]    => BMW                                               - Имя марки
[t1]           => Трансмиссия                                       - Имя узла
[t2]           => Коробка передач                                   - Имя узла
[t3]           => A4S200R Сальник вх.вала/датчик частоты вращения   - Имя узла
[detail_name]  => Болт TORX                                         - Наименование детали
[detail_no]    => 24 12 1 218 892                                   - Номер детали
[actual]       => 2006                                              - Актуальность каталога
```
>на примере одного объекта
в массиве все необходимы данные для построения дерева.  
Пример в adc/search/detail.php
